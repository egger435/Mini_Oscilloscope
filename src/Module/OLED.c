#include "stm32f10x.h"
#include "IIC.h"
#include "Delay.h"
#include "OLED.h"

// 6x8字模数据
const uint8_t OLED_F6x8[95][6] = 
{
	{0x00,0x00,0x00,0x00,0x00,0x00},//   0
	{0x00,0x00,0x00,0x2F,0x00,0x00},// ! 1
	{0x00,0x00,0x07,0x00,0x07,0x00},// " 2
	{0x00,0x14,0x7F,0x14,0x7F,0x14},// # 3
	{0x00,0x24,0x2A,0x7F,0x2A,0x12},// $ 4
	{0x00,0x23,0x13,0x08,0x64,0x62},// % 5
	{0x00,0x36,0x49,0x55,0x22,0x50},// & 6
	{0x00,0x00,0x00,0x07,0x00,0x00},// ' 7
	{0x00,0x00,0x1C,0x22,0x41,0x00},// ( 8
	{0x00,0x00,0x41,0x22,0x1C,0x00},// ) 9
	{0x00,0x14,0x08,0x3E,0x08,0x14},// * 10
	{0x00,0x08,0x08,0x3E,0x08,0x08},// + 11
	{0x00,0x00,0x00,0xA0,0x60,0x00},// , 12
	{0x00,0x08,0x08,0x08,0x08,0x08},// - 13
	{0x00,0x00,0x60,0x60,0x00,0x00},// . 14
	{0x00,0x20,0x10,0x08,0x04,0x02},// / 15
	{0x00,0x3E,0x51,0x49,0x45,0x3E},// 0 16
	{0x00,0x00,0x42,0x7F,0x40,0x00},// 1 17
	{0x00,0x42,0x61,0x51,0x49,0x46},// 2 18
	{0x00,0x21,0x41,0x45,0x4B,0x31},// 3 19
	{0x00,0x18,0x14,0x12,0x7F,0x10},// 4 20
	{0x00,0x27,0x45,0x45,0x45,0x39},// 5 21
	{0x00,0x3C,0x4A,0x49,0x49,0x30},// 6 22
	{0x00,0x01,0x71,0x09,0x05,0x03},// 7 23
	{0x00,0x36,0x49,0x49,0x49,0x36},// 8 24
	{0x00,0x06,0x49,0x49,0x29,0x1E},// 9 25
	{0x00,0x00,0x36,0x36,0x00,0x00},// : 26
	{0x00,0x00,0x56,0x36,0x00,0x00},// ; 27
	{0x00,0x08,0x14,0x22,0x41,0x00},// < 28
	{0x00,0x14,0x14,0x14,0x14,0x14},// = 29
	{0x00,0x00,0x41,0x22,0x14,0x08},// > 30
	{0x00,0x02,0x01,0x51,0x09,0x06},// ? 31
	{0x00,0x3E,0x49,0x55,0x59,0x2E},// @ 32
	{0x00,0x7C,0x12,0x11,0x12,0x7C},// A 33
	{0x00,0x7F,0x49,0x49,0x49,0x36},// B 34
	{0x00,0x3E,0x41,0x41,0x41,0x22},// C 35
	{0x00,0x7F,0x41,0x41,0x22,0x1C},// D 36
	{0x00,0x7F,0x49,0x49,0x49,0x41},// E 37
	{0x00,0x7F,0x09,0x09,0x09,0x01},// F 38
	{0x00,0x3E,0x41,0x49,0x49,0x7A},// G 39
	{0x00,0x7F,0x08,0x08,0x08,0x7F},// H 40
	{0x00,0x00,0x41,0x7F,0x41,0x00},// I 41
	{0x00,0x20,0x40,0x41,0x3F,0x01},// J 42
	{0x00,0x7F,0x08,0x14,0x22,0x41},// K 43
	{0x00,0x7F,0x40,0x40,0x40,0x40},// L 44
	{0x00,0x7F,0x02,0x0C,0x02,0x7F},// M 45
	{0x00,0x7F,0x04,0x08,0x10,0x7F},// N 46
	{0x00,0x3E,0x41,0x41,0x41,0x3E},// O 47
	{0x00,0x7F,0x09,0x09,0x09,0x06},// P 48
	{0x00,0x3E,0x41,0x51,0x21,0x5E},// Q 49
	{0x00,0x7F,0x09,0x19,0x29,0x46},// R 50
	{0x00,0x46,0x49,0x49,0x49,0x31},// S 51
	{0x00,0x01,0x01,0x7F,0x01,0x01},// T 52
	{0x00,0x3F,0x40,0x40,0x40,0x3F},// U 53
	{0x00,0x1F,0x20,0x40,0x20,0x1F},// V 54
	{0x00,0x3F,0x40,0x38,0x40,0x3F},// W 55
	{0x00,0x63,0x14,0x08,0x14,0x63},// X 56
	{0x00,0x07,0x08,0x70,0x08,0x07},// Y 57
	{0x00,0x61,0x51,0x49,0x45,0x43},// Z 58
	{0x00,0x00,0x7F,0x41,0x41,0x00},// [ 59
	{0x00,0x02,0x04,0x08,0x10,0x20},// \ 60
	{0x00,0x00,0x41,0x41,0x7F,0x00},// ] 61
	{0x00,0x04,0x02,0x01,0x02,0x04},// ^ 62
	{0x00,0x40,0x40,0x40,0x40,0x40},// _ 63
	{0x00,0x00,0x01,0x02,0x04,0x00},// ` 64
	{0x00,0x20,0x54,0x54,0x54,0x78},// a 65
	{0x00,0x7F,0x48,0x44,0x44,0x38},// b 66
	{0x00,0x38,0x44,0x44,0x44,0x20},// c 67
	{0x00,0x38,0x44,0x44,0x48,0x7F},// d 68
	{0x00,0x38,0x54,0x54,0x54,0x18},// e 69
	{0x00,0x08,0x7E,0x09,0x01,0x02},// f 70
	{0x00,0x18,0xA4,0xA4,0xA4,0x7C},// g 71
	{0x00,0x7F,0x08,0x04,0x04,0x78},// h 72
	{0x00,0x00,0x44,0x7D,0x40,0x00},// i 73
	{0x00,0x40,0x80,0x84,0x7D,0x00},// j 74
	{0x00,0x7F,0x10,0x28,0x44,0x00},// k 75
	{0x00,0x00,0x41,0x7F,0x40,0x00},// l 76
	{0x00,0x7C,0x04,0x18,0x04,0x78},// m 77
	{0x00,0x7C,0x08,0x04,0x04,0x78},// n 78
	{0x00,0x38,0x44,0x44,0x44,0x38},// o 79
	{0x00,0xFC,0x24,0x24,0x24,0x18},// p 80
	{0x00,0x18,0x24,0x24,0x18,0xFC},// q 81
	{0x00,0x7C,0x08,0x04,0x04,0x08},// r 82
	{0x00,0x48,0x54,0x54,0x54,0x20},// s 83
	{0x00,0x04,0x3F,0x44,0x40,0x20},// t 84
	{0x00,0x3C,0x40,0x40,0x20,0x7C},// u 85
	{0x00,0x1C,0x20,0x40,0x20,0x1C},// v 86
	{0x00,0x3C,0x40,0x30,0x40,0x3C},// w 87
	{0x00,0x44,0x28,0x10,0x28,0x44},// x 88
	{0x00,0x1C,0xA0,0xA0,0xA0,0x7C},// y 89
	{0x00,0x44,0x64,0x54,0x4C,0x44},// z 90
	{0x00,0x00,0x08,0x7F,0x41,0x00},// { 91
	{0x00,0x00,0x00,0x7F,0x00,0x00},// | 92
	{0x00,0x00,0x41,0x7F,0x08,0x00},// } 93
	{0x00,0x08,0x04,0x08,0x10,0x08},// ~ 94
};

uint8_t OLED_Buffer[8][128];  // 显示缓存

// OLED初始化
void OLED_Init(void)
{
    IIC_Init();

    Delay_ms(100);

    // 一系列初始化命令
    OLED_WriteCmd(0xAE);
    OLED_WriteCmd(0xD5);
    OLED_WriteCmd(0x80);
    OLED_WriteCmd(0xA8);
    OLED_WriteCmd(0x3F);
    OLED_WriteCmd(0xD3);
    OLED_WriteCmd(0x00);
    OLED_WriteCmd(0x40);
    OLED_WriteCmd(0xA1);
    OLED_WriteCmd(0xC8);
    OLED_WriteCmd(0xDA);
    OLED_WriteCmd(0x12);
    OLED_WriteCmd(0x81);
    OLED_WriteCmd(0xCF);
    OLED_WriteCmd(0xD9);
    OLED_WriteCmd(0xF1);
    OLED_WriteCmd(0xDB);
    OLED_WriteCmd(0x30);
    OLED_WriteCmd(0xA4);
    OLED_WriteCmd(0xA6);
    OLED_WriteCmd(0x8D);
    OLED_WriteCmd(0x14);
    OLED_WriteCmd(0xAF);

    Delay_ms(100);
}

// 写入指令
void OLED_WriteCmd(uint8_t cmd)
{ 
    // 通信开始
    IIC_Start();
    IIC_SendByte(0x78);  // OLED地址
    IIC_ReceiveAck();

    IIC_SendByte(0x00);  // 非连续模式，写“命令”
    IIC_ReceiveAck();

    IIC_SendByte(cmd);   // 发送命令
    IIC_ReceiveAck();
    IIC_Stop();          // 通信结束
}

// 写入数据
void OLED_WriteData(uint8_t *data, uint8_t count)
{
    // 通信开始
    IIC_Start();
    IIC_SendByte(0x78);
    IIC_ReceiveAck();

    IIC_SendByte(0x40);  // 连续模式，写“数据”
    IIC_ReceiveAck();
	for (uint8_t i = 0; i < count; i++)
	{
		IIC_SendByte(data[i]);  // 发送数据
    	IIC_ReceiveAck();
	}
    
    IIC_Stop();
}

/// @brief 设置光标位置
/// @param x 列 0-127
/// @param page 页 0-7
void OLED_SetCursor(uint8_t x, uint8_t page)
{
	// 通信开始
    IIC_Start();
    IIC_SendByte(0x78);  // OLED地址
    IIC_ReceiveAck();

    IIC_SendByte(0x00);  // 连续模式，写“命令”
    IIC_ReceiveAck();

    IIC_SendByte(0x00 | (x & 0x0F));   // 设置低四位
	IIC_ReceiveAck();
	IIC_SendByte(0x10 | (x & 0xF0) >> 4); // 设置高四位
	IIC_ReceiveAck();
	IIC_SendByte(0xB0 | page);  // 设置页地址
    IIC_ReceiveAck();
    IIC_Stop();          // 通信结束
}

// 更新显示
void OLED_Update(void)
{
	for (uint8_t page = 0; page < 8; page++)
	{
		OLED_SetCursor(0, page);
		OLED_WriteData(OLED_Buffer[page], 128);  // 更新数据
	}
}

/// @brief 清屏
void OLED_Clear(void)
{
    for (uint8_t page = 0; page < 8; page++)
    {
        OLED_SetCursor(0, page);
        for (uint8_t x = 0; x < 128; x++)
        {
            OLED_Buffer[page][x] = 0x00; 
        }
    }
}

/// @brief 显示字符
void OLED_ShowChar(uint8_t x, uint8_t page, char ch)
{
    if (x > 127 || page > 7) return;  // 超出范围

    for (uint8_t i = 0; i < 6; i++)
    {
        OLED_Buffer[page][x + i] = OLED_F6x8[ch - ' '][i];  
    }
}

/// @brief 显示字符串
void OLED_ShowString(uint8_t x, uint8_t page, const char *str)
{
    while (*str)
    {
        OLED_ShowChar(x, page, *str);
        x += 6;  // 每个字符宽度为6
        str++;
    }
}

// OLED工具函数
uint32_t OLED_Pow(uint32_t x, uint32_t y)
{
	uint32_t res = 1;
	while (y--)
	{
		res *= x;
	}
	return res;
}

/// @brief 显示数字
void OLED_ShowNum(uint8_t x, uint8_t page, uint32_t num, uint8_t len)
{
	for (uint8_t i = 0; i < len; i++)
	{
		OLED_ShowChar(x + i * 6, page, (num / OLED_Pow(10, len - i - 1)) % 10 + '0');
	}
}

/// @brief 绘制点
void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t state)
{
    if (x > 127 || y > 63) return;

    uint8_t page = y / 8;  // 页地址
    uint8_t bit = y % 8;   // 位地址

    if (state)
    {
        OLED_Buffer[page][x] |= (1 << bit);  // 设置点
    }
    else
    {
        OLED_Buffer[page][x] &= ~(1 << bit); // 清除点
    }
}

/// @brief 绘制线段
void OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2)
{
    // Bresenham 直线算法
    int dx = x2 - x1;
    int dy = y2 - y1;
    int abs_dx = (dx < 0) ? -dx : dx;
    int abs_dy = (dy < 0) ? -dy : dy;
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = abs_dx - abs_dy;

    while (1)
    {
        OLED_DrawPoint(x1, y1, 1);  
        if (x1 == x2 && y1 == y2) break;

        int e2 = err * 2;
        if (e2 > -abs_dy)
        {
            err -= abs_dy;
            x1 += sx;
        }
        if (e2 < abs_dx)
        {
            err += abs_dx;
            y1 += sy;
        }
    }
}